import fs from"fs";import path from"path";import url from"url";function content(t){return new Promise(((a,e)=>{let n=[];t.on("data",n.push.bind(n)),t.on("end",(()=>{a(Buffer.concat(n))})),t.on("error",e)}))}async function createReadStream(t){let a;try{a=await fs.promises.open(t,"r")}catch(t){throw["ENOENT"].includes(t.code)?createReadStream.badPath:t}if(!(await a.stat()).isFile())throw a.close(),createReadStream.badPath;return fs.createReadStream(0,{fd:a.fd,autoClose:!1}).on("end",(()=>a.close()))}async function existFile(t){try{return await fs.promises.stat(t),1}catch(t){if("ENOENT"!=t.code)throw t}}async function fsyncByPath(t){let a=await fs.promises.open(t);await a.sync(),await a.close()}async function fsyncWithParentByPath(t){await Promise.all([fsyncByPath(path.resolve(t,"..")),fsyncByPath(t)])}function importMetaToDir(t){return path.dirname(new url.URL(t.url).pathname)}async function mkdirFsync(t){await fs.promises.mkdir(t),await fsyncWithParentByPath(t)}function onceSigintOrSigterm(t){function a(){process.off("SIGINT",a).off("SIGTERM",a),t()}process.on("SIGINT",a).on("SIGTERM",a)}async function renameFsync(t,a){await fs.promises.rename(t,a),await fsyncByPath(t)}createReadStream.badPath=Symbol();var main={content:content,createReadStream:createReadStream,existFile:existFile,fsyncByPath:fsyncByPath,fsyncWithParentByPath:fsyncWithParentByPath,importMetaToDir:importMetaToDir,mkdirFsync:mkdirFsync,onceSigintOrSigterm:onceSigintOrSigterm,renameFsync:renameFsync};export default main;